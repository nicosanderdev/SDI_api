//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IClient {
    postRegister(registration: RegisterRequest): Observable<void>;
    postLogin(useCookies: boolean | null | undefined, useSessionCookies: boolean | null | undefined, login: LoginRequest): Observable<AccessTokenResponse>;
    postRefresh(refreshRequest: RefreshRequest): Observable<AccessTokenResponse>;
    getConfirmEmail(userId: string | null, code: string | null, changedEmail: string | null | undefined): Observable<void>;
    postResendConfirmationEmail(resendRequest: ResendConfirmationEmailRequest): Observable<void>;
    postForgotPassword(resetRequest: ForgotPasswordRequest): Observable<void>;
    postResetPassword(resetRequest: ResetPasswordRequest): Observable<void>;
    postManage2fa(tfaRequest: TwoFactorRequest): Observable<TwoFactorResponse>;
    getManageInfo(): Observable<InfoResponse>;
    postManageInfo(infoRequest: InfoRequest): Observable<InfoResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class Client implements IClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    postRegister(registration: RegisterRequest): Observable<void> {
        let url_ = this.baseUrl + "/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(registration);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostRegister(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postLogin(useCookies: boolean | null | undefined, useSessionCookies: boolean | null | undefined, login: LoginRequest): Observable<AccessTokenResponse> {
        let url_ = this.baseUrl + "/login?";
        if (useCookies !== undefined && useCookies !== null)
            url_ += "useCookies=" + encodeURIComponent("" + useCookies) + "&";
        if (useSessionCookies !== undefined && useSessionCookies !== null)
            url_ += "useSessionCookies=" + encodeURIComponent("" + useSessionCookies) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(login);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccessTokenResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccessTokenResponse>;
        }));
    }

    protected processPostLogin(response: HttpResponseBase): Observable<AccessTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessTokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postRefresh(refreshRequest: RefreshRequest): Observable<AccessTokenResponse> {
        let url_ = this.baseUrl + "/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(refreshRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostRefresh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostRefresh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccessTokenResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccessTokenResponse>;
        }));
    }

    protected processPostRefresh(response: HttpResponseBase): Observable<AccessTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AccessTokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getConfirmEmail(userId: string | null, code: string | null, changedEmail: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/confirmEmail?";
        if (userId === undefined)
            throw new Error("The parameter 'userId' must be defined.");
        else if(userId !== null)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (code === undefined)
            throw new Error("The parameter 'code' must be defined.");
        else if(code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (changedEmail !== undefined && changedEmail !== null)
            url_ += "changedEmail=" + encodeURIComponent("" + changedEmail) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfirmEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfirmEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetConfirmEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postResendConfirmationEmail(resendRequest: ResendConfirmationEmailRequest): Observable<void> {
        let url_ = this.baseUrl + "/resendConfirmationEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resendRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostResendConfirmationEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostResendConfirmationEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostResendConfirmationEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postForgotPassword(resetRequest: ForgotPasswordRequest): Observable<void> {
        let url_ = this.baseUrl + "/forgotPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resetRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostForgotPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostForgotPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postResetPassword(resetRequest: ResetPasswordRequest): Observable<void> {
        let url_ = this.baseUrl + "/resetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resetRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPostResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postManage2fa(tfaRequest: TwoFactorRequest): Observable<TwoFactorResponse> {
        let url_ = this.baseUrl + "/manage/2fa";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(tfaRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostManage2fa(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostManage2fa(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TwoFactorResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TwoFactorResponse>;
        }));
    }

    protected processPostManage2fa(response: HttpResponseBase): Observable<TwoFactorResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TwoFactorResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getManageInfo(): Observable<InfoResponse> {
        let url_ = this.baseUrl + "/manage/info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManageInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManageInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InfoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InfoResponse>;
        }));
    }

    protected processGetManageInfo(response: HttpResponseBase): Observable<InfoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InfoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    postManageInfo(infoRequest: InfoRequest): Observable<InfoResponse> {
        let url_ = this.baseUrl + "/manage/info";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(infoRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostManageInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostManageInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InfoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InfoResponse>;
        }));
    }

    protected processPostManageInfo(response: HttpResponseBase): Observable<InfoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InfoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = HttpValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAuthClient {
    auth_Login(command: LoginCommand): Observable<LoginResultDto>;
    auth_Logout(): Observable<FileResponse>;
    auth_Verify(): Observable<UserDto>;
    auth_ForgotPasswordCustom(command: ForgotPasswordCommand): Observable<FileResponse>;
    auth_ResetPasswordCustom(command: ResetPasswordCommand): Observable<void>;
    auth_ConfirmEmailCustom(command: ConfirmEmailCommand): Observable<void>;
    auth_ResendConfirmationEmailCustom(dto: ResendConfirmationEmailDto): Observable<void>;
    auth_GenerateTwoFactorKeyCustom(): Observable<GenerateTwoFactorKeyResponse>;
    auth_EnableTwoFactorAuthCustom(request: Enable2faRequest): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class AuthClient implements IAuthClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    auth_Login(command: LoginCommand): Observable<LoginResultDto> {
        let url_ = this.baseUrl + "/api/auth/loginCustom";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_Login(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_Login(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginResultDto>;
        }));
    }

    protected processAuth_Login(response: HttpResponseBase): Observable<LoginResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = LoginResultDto.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    auth_Logout(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/auth/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_Logout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_Logout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processAuth_Logout(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    auth_Verify(): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/auth/verify";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_Verify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_Verify(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDto>;
        }));
    }

    protected processAuth_Verify(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    auth_ForgotPasswordCustom(command: ForgotPasswordCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/auth/forgot-password-custom";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_ForgotPasswordCustom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_ForgotPasswordCustom(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processAuth_ForgotPasswordCustom(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    auth_ResetPasswordCustom(command: ResetPasswordCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/auth/reset-password-custom";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_ResetPasswordCustom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_ResetPasswordCustom(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAuth_ResetPasswordCustom(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    auth_ConfirmEmailCustom(command: ConfirmEmailCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/auth/confirm-email-custom";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_ConfirmEmailCustom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_ConfirmEmailCustom(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAuth_ConfirmEmailCustom(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    auth_ResendConfirmationEmailCustom(dto: ResendConfirmationEmailDto): Observable<void> {
        let url_ = this.baseUrl + "/api/auth/resend-confirmation-email-custom";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_ResendConfirmationEmailCustom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_ResendConfirmationEmailCustom(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAuth_ResendConfirmationEmailCustom(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    auth_GenerateTwoFactorKeyCustom(): Observable<GenerateTwoFactorKeyResponse> {
        let url_ = this.baseUrl + "/api/auth/2fa/generate-custom";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_GenerateTwoFactorKeyCustom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_GenerateTwoFactorKeyCustom(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenerateTwoFactorKeyResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenerateTwoFactorKeyResponse>;
        }));
    }

    protected processAuth_GenerateTwoFactorKeyCustom(response: HttpResponseBase): Observable<GenerateTwoFactorKeyResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenerateTwoFactorKeyResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    auth_EnableTwoFactorAuthCustom(request: Enable2faRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/auth/2fa/enable-custom";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuth_EnableTwoFactorAuthCustom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuth_EnableTwoFactorAuthCustom(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAuth_EnableTwoFactorAuthCustom(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = Result.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IEstatePropertiesClient {
    estateProperties_GetEstateProperties(pageNumber: number | undefined, pageSize: number | undefined, filter_IsDeleted: boolean | null | undefined, filter_OwnerId: string | null | undefined, filter_CreatedAfter: Date | null | undefined, filter_CreatedBefore: Date | null | undefined, filter_Status: string | null | undefined, filter_SearchTerm: string | null | undefined): Observable<FileResponse>;
    estateProperties_CreateEstateProperty(command: CreateEstatePropertyCommand): Observable<void>;
    estateProperties_GetEstateProperty(id: string): Observable<FileResponse>;
    estateProperties_UpdateEstateProperty(id: string, command: UpdateEstatePropertyCommand): Observable<void>;
    estateProperties_DeleteEstateProperty(id: string): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class EstatePropertiesClient implements IEstatePropertiesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    estateProperties_GetEstateProperties(pageNumber: number | undefined, pageSize: number | undefined, filter_IsDeleted: boolean | null | undefined, filter_OwnerId: string | null | undefined, filter_CreatedAfter: Date | null | undefined, filter_CreatedBefore: Date | null | undefined, filter_Status: string | null | undefined, filter_SearchTerm: string | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/properties?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (filter_IsDeleted !== undefined && filter_IsDeleted !== null)
            url_ += "Filter.IsDeleted=" + encodeURIComponent("" + filter_IsDeleted) + "&";
        if (filter_OwnerId !== undefined && filter_OwnerId !== null)
            url_ += "Filter.OwnerId=" + encodeURIComponent("" + filter_OwnerId) + "&";
        if (filter_CreatedAfter !== undefined && filter_CreatedAfter !== null)
            url_ += "Filter.CreatedAfter=" + encodeURIComponent(filter_CreatedAfter ? "" + filter_CreatedAfter.toISOString() : "") + "&";
        if (filter_CreatedBefore !== undefined && filter_CreatedBefore !== null)
            url_ += "Filter.CreatedBefore=" + encodeURIComponent(filter_CreatedBefore ? "" + filter_CreatedBefore.toISOString() : "") + "&";
        if (filter_Status !== undefined && filter_Status !== null)
            url_ += "Filter.Status=" + encodeURIComponent("" + filter_Status) + "&";
        if (filter_SearchTerm !== undefined && filter_SearchTerm !== null)
            url_ += "Filter.SearchTerm=" + encodeURIComponent("" + filter_SearchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEstateProperties_GetEstateProperties(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEstateProperties_GetEstateProperties(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processEstateProperties_GetEstateProperties(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    estateProperties_CreateEstateProperty(command: CreateEstatePropertyCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/properties";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEstateProperties_CreateEstateProperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEstateProperties_CreateEstateProperty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEstateProperties_CreateEstateProperty(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    estateProperties_GetEstateProperty(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/properties/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEstateProperties_GetEstateProperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEstateProperties_GetEstateProperty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processEstateProperties_GetEstateProperty(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    estateProperties_UpdateEstateProperty(id: string, command: UpdateEstatePropertyCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/properties/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEstateProperties_UpdateEstateProperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEstateProperties_UpdateEstateProperty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEstateProperties_UpdateEstateProperty(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    estateProperties_DeleteEstateProperty(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/properties/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEstateProperties_DeleteEstateProperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEstateProperties_DeleteEstateProperty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEstateProperties_DeleteEstateProperty(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IMessagesClient {
    messages_GetMessages(page: number | undefined, limit: number | undefined, filter: string | null | undefined, query: string | null | undefined, propertyId: string | null | undefined, sortBy: string | null | undefined): Observable<PaginatedMessageResultDto>;
    messages_SendMessage(messageData: SendMessageDto): Observable<MessageDto>;
    messages_GetMessageById(id: string): Observable<MessageDetailDto>;
    messages_DeleteMessage(id: string): Observable<FileResponse>;
    messages_MarkMessageAsRead(id: string): Observable<FileResponse>;
    messages_GetMessageCounts(): Observable<TabCountsDto>;
}

@Injectable({
    providedIn: 'root'
})
export class MessagesClient implements IMessagesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    messages_GetMessages(page: number | undefined, limit: number | undefined, filter: string | null | undefined, query: string | null | undefined, propertyId: string | null | undefined, sortBy: string | null | undefined): Observable<PaginatedMessageResultDto> {
        let url_ = this.baseUrl + "/api/messages?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (query !== undefined && query !== null)
            url_ += "Query=" + encodeURIComponent("" + query) + "&";
        if (propertyId !== undefined && propertyId !== null)
            url_ += "PropertyId=" + encodeURIComponent("" + propertyId) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMessages_GetMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMessages_GetMessages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaginatedMessageResultDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaginatedMessageResultDto>;
        }));
    }

    protected processMessages_GetMessages(response: HttpResponseBase): Observable<PaginatedMessageResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginatedMessageResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    messages_SendMessage(messageData: SendMessageDto): Observable<MessageDto> {
        let url_ = this.baseUrl + "/api/messages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(messageData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMessages_SendMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMessages_SendMessage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MessageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MessageDto>;
        }));
    }

    protected processMessages_SendMessage(response: HttpResponseBase): Observable<MessageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    messages_GetMessageById(id: string): Observable<MessageDetailDto> {
        let url_ = this.baseUrl + "/api/messages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMessages_GetMessageById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMessages_GetMessageById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MessageDetailDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MessageDetailDto>;
        }));
    }

    protected processMessages_GetMessageById(response: HttpResponseBase): Observable<MessageDetailDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MessageDetailDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    messages_DeleteMessage(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/messages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMessages_DeleteMessage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMessages_DeleteMessage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processMessages_DeleteMessage(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    messages_MarkMessageAsRead(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/messages/{id}/read";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMessages_MarkMessageAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMessages_MarkMessageAsRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processMessages_MarkMessageAsRead(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    messages_GetMessageCounts(): Observable<TabCountsDto> {
        let url_ = this.baseUrl + "/api/messages/counts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMessages_GetMessageCounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMessages_GetMessageCounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TabCountsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TabCountsDto>;
        }));
    }

    protected processMessages_GetMessageCounts(response: HttpResponseBase): Observable<TabCountsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TabCountsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IProfilesClient {
    profiles_GetCurrentUserProfile(): Observable<ProfileDataDto>;
    profiles_UpdateCurrentUserProfile(profileUpdateData: UpdateProfileDto): Observable<ProfileDataDto>;
    profiles_ChangeUserPassword(passwordData: ChangePasswordDto): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ProfilesClient implements IProfilesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    profiles_GetCurrentUserProfile(): Observable<ProfileDataDto> {
        let url_ = this.baseUrl + "/api/profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfiles_GetCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfiles_GetCurrentUserProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProfileDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProfileDataDto>;
        }));
    }

    protected processProfiles_GetCurrentUserProfile(response: HttpResponseBase): Observable<ProfileDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfileDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    profiles_UpdateCurrentUserProfile(profileUpdateData: UpdateProfileDto): Observable<ProfileDataDto> {
        let url_ = this.baseUrl + "/api/profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(profileUpdateData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfiles_UpdateCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfiles_UpdateCurrentUserProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ProfileDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ProfileDataDto>;
        }));
    }

    protected processProfiles_UpdateCurrentUserProfile(response: HttpResponseBase): Observable<ProfileDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProfileDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    profiles_ChangeUserPassword(passwordData: ChangePasswordDto): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/profile/change-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(passwordData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processProfiles_ChangeUserPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processProfiles_ChangeUserPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processProfiles_ChangeUserPassword(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IReportsClient {
    reports_GetMonthlySummary(year: number | undefined, month: number | undefined): Observable<MonthlySummaryDataDto>;
    reports_GetGeneralTotals(): Observable<GeneralTotalsDataDto>;
    reports_GetVisitsByProperty(period: string | undefined, page: number | undefined, limit: number | undefined): Observable<VisitsByPropertyDataDto>;
    reports_GetPropertySpecificReport(propertyId: string, period: string | undefined): Observable<PropertySpecificReportDataDto>;
    reports_GetDashboardSummary(period: string | null | undefined): Observable<DashboardSummaryDataDto>;
    reports_GetDailyVisits(period: string | undefined, dateFormat: string | undefined): Observable<DailyVisitDto[]>;
    reports_GetVisitsBySource(period: string | undefined): Observable<VisitSourceDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class ReportsClient implements IReportsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    reports_GetMonthlySummary(year: number | undefined, month: number | undefined): Observable<MonthlySummaryDataDto> {
        let url_ = this.baseUrl + "/api/reports/monthly-summary?";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "Year=" + encodeURIComponent("" + year) + "&";
        if (month === null)
            throw new Error("The parameter 'month' cannot be null.");
        else if (month !== undefined)
            url_ += "Month=" + encodeURIComponent("" + month) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReports_GetMonthlySummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReports_GetMonthlySummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MonthlySummaryDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MonthlySummaryDataDto>;
        }));
    }

    protected processReports_GetMonthlySummary(response: HttpResponseBase): Observable<MonthlySummaryDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MonthlySummaryDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    reports_GetGeneralTotals(): Observable<GeneralTotalsDataDto> {
        let url_ = this.baseUrl + "/api/reports/totals";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReports_GetGeneralTotals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReports_GetGeneralTotals(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GeneralTotalsDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GeneralTotalsDataDto>;
        }));
    }

    protected processReports_GetGeneralTotals(response: HttpResponseBase): Observable<GeneralTotalsDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GeneralTotalsDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    reports_GetVisitsByProperty(period: string | undefined, page: number | undefined, limit: number | undefined): Observable<VisitsByPropertyDataDto> {
        let url_ = this.baseUrl + "/api/reports/property-visits?";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent("" + period) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReports_GetVisitsByProperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReports_GetVisitsByProperty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VisitsByPropertyDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VisitsByPropertyDataDto>;
        }));
    }

    protected processReports_GetVisitsByProperty(response: HttpResponseBase): Observable<VisitsByPropertyDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VisitsByPropertyDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    reports_GetPropertySpecificReport(propertyId: string, period: string | undefined): Observable<PropertySpecificReportDataDto> {
        let url_ = this.baseUrl + "/api/reports/properties/{propertyId}?";
        if (propertyId === undefined || propertyId === null)
            throw new Error("The parameter 'propertyId' must be defined.");
        url_ = url_.replace("{propertyId}", encodeURIComponent("" + propertyId));
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "period=" + encodeURIComponent("" + period) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReports_GetPropertySpecificReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReports_GetPropertySpecificReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PropertySpecificReportDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PropertySpecificReportDataDto>;
        }));
    }

    protected processReports_GetPropertySpecificReport(response: HttpResponseBase): Observable<PropertySpecificReportDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PropertySpecificReportDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    reports_GetDashboardSummary(period: string | null | undefined): Observable<DashboardSummaryDataDto> {
        let url_ = this.baseUrl + "/api/reports/dashboard-summary?";
        if (period !== undefined && period !== null)
            url_ += "Period=" + encodeURIComponent("" + period) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReports_GetDashboardSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReports_GetDashboardSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashboardSummaryDataDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashboardSummaryDataDto>;
        }));
    }

    protected processReports_GetDashboardSummary(response: HttpResponseBase): Observable<DashboardSummaryDataDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardSummaryDataDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    reports_GetDailyVisits(period: string | undefined, dateFormat: string | undefined): Observable<DailyVisitDto[]> {
        let url_ = this.baseUrl + "/api/reports/daily-visits?";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent("" + period) + "&";
        if (dateFormat === null)
            throw new Error("The parameter 'dateFormat' cannot be null.");
        else if (dateFormat !== undefined)
            url_ += "DateFormat=" + encodeURIComponent("" + dateFormat) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReports_GetDailyVisits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReports_GetDailyVisits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DailyVisitDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DailyVisitDto[]>;
        }));
    }

    protected processReports_GetDailyVisits(response: HttpResponseBase): Observable<DailyVisitDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DailyVisitDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    reports_GetVisitsBySource(period: string | undefined): Observable<VisitSourceDto[]> {
        let url_ = this.baseUrl + "/api/reports/visits-by-source?";
        if (period === null)
            throw new Error("The parameter 'period' cannot be null.");
        else if (period !== undefined)
            url_ += "Period=" + encodeURIComponent("" + period) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReports_GetVisitsBySource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReports_GetVisitsBySource(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VisitSourceDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VisitSourceDto[]>;
        }));
    }

    protected processReports_GetVisitsBySource(response: HttpResponseBase): Observable<VisitSourceDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VisitSourceDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export class HttpValidationProblemDetails extends ProblemDetails implements IHttpValidationProblemDetails {
    errors?: { [key: string]: string[]; };

    [key: string]: any;

    constructor(data?: IHttpValidationProblemDetails) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static override fromJS(data: any): HttpValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new HttpValidationProblemDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IHttpValidationProblemDetails extends IProblemDetails {
    errors?: { [key: string]: string[]; };

    [key: string]: any;
}

export class RegisterRequest implements IRegisterRequest {
    email?: string;
    password?: string;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IRegisterRequest {
    email?: string;
    password?: string;
}

export class AccessTokenResponse implements IAccessTokenResponse {
    tokenType?: string;
    accessToken?: string;
    expiresIn?: number;
    refreshToken?: string;

    constructor(data?: IAccessTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tokenType = _data["tokenType"];
            this.accessToken = _data["accessToken"];
            this.expiresIn = _data["expiresIn"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): AccessTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AccessTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tokenType"] = this.tokenType;
        data["accessToken"] = this.accessToken;
        data["expiresIn"] = this.expiresIn;
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IAccessTokenResponse {
    tokenType?: string;
    accessToken?: string;
    expiresIn?: number;
    refreshToken?: string;
}

export class LoginRequest implements ILoginRequest {
    email?: string;
    password?: string;
    twoFactorCode?: string | undefined;
    twoFactorRecoveryCode?: string | undefined;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.twoFactorCode = _data["twoFactorCode"];
            this.twoFactorRecoveryCode = _data["twoFactorRecoveryCode"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["twoFactorCode"] = this.twoFactorCode;
        data["twoFactorRecoveryCode"] = this.twoFactorRecoveryCode;
        return data;
    }
}

export interface ILoginRequest {
    email?: string;
    password?: string;
    twoFactorCode?: string | undefined;
    twoFactorRecoveryCode?: string | undefined;
}

export class RefreshRequest implements IRefreshRequest {
    refreshToken?: string;

    constructor(data?: IRefreshRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): RefreshRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IRefreshRequest {
    refreshToken?: string;
}

export class ResendConfirmationEmailRequest implements IResendConfirmationEmailRequest {
    email?: string;

    constructor(data?: IResendConfirmationEmailRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ResendConfirmationEmailRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResendConfirmationEmailRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IResendConfirmationEmailRequest {
    email?: string;
}

export class ForgotPasswordRequest implements IForgotPasswordRequest {
    email?: string;

    constructor(data?: IForgotPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IForgotPasswordRequest {
    email?: string;
}

export class ResetPasswordRequest implements IResetPasswordRequest {
    email?: string;
    resetCode?: string;
    newPassword?: string;

    constructor(data?: IResetPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.resetCode = _data["resetCode"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["resetCode"] = this.resetCode;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IResetPasswordRequest {
    email?: string;
    resetCode?: string;
    newPassword?: string;
}

export class TwoFactorResponse implements ITwoFactorResponse {
    sharedKey?: string;
    recoveryCodesLeft?: number;
    recoveryCodes?: string[] | undefined;
    isTwoFactorEnabled?: boolean;
    isMachineRemembered?: boolean;

    constructor(data?: ITwoFactorResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sharedKey = _data["sharedKey"];
            this.recoveryCodesLeft = _data["recoveryCodesLeft"];
            if (Array.isArray(_data["recoveryCodes"])) {
                this.recoveryCodes = [] as any;
                for (let item of _data["recoveryCodes"])
                    this.recoveryCodes!.push(item);
            }
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            this.isMachineRemembered = _data["isMachineRemembered"];
        }
    }

    static fromJS(data: any): TwoFactorResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sharedKey"] = this.sharedKey;
        data["recoveryCodesLeft"] = this.recoveryCodesLeft;
        if (Array.isArray(this.recoveryCodes)) {
            data["recoveryCodes"] = [];
            for (let item of this.recoveryCodes)
                data["recoveryCodes"].push(item);
        }
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isMachineRemembered"] = this.isMachineRemembered;
        return data;
    }
}

export interface ITwoFactorResponse {
    sharedKey?: string;
    recoveryCodesLeft?: number;
    recoveryCodes?: string[] | undefined;
    isTwoFactorEnabled?: boolean;
    isMachineRemembered?: boolean;
}

export class TwoFactorRequest implements ITwoFactorRequest {
    enable?: boolean | undefined;
    twoFactorCode?: string | undefined;
    resetSharedKey?: boolean;
    resetRecoveryCodes?: boolean;
    forgetMachine?: boolean;

    constructor(data?: ITwoFactorRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enable = _data["enable"];
            this.twoFactorCode = _data["twoFactorCode"];
            this.resetSharedKey = _data["resetSharedKey"];
            this.resetRecoveryCodes = _data["resetRecoveryCodes"];
            this.forgetMachine = _data["forgetMachine"];
        }
    }

    static fromJS(data: any): TwoFactorRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enable"] = this.enable;
        data["twoFactorCode"] = this.twoFactorCode;
        data["resetSharedKey"] = this.resetSharedKey;
        data["resetRecoveryCodes"] = this.resetRecoveryCodes;
        data["forgetMachine"] = this.forgetMachine;
        return data;
    }
}

export interface ITwoFactorRequest {
    enable?: boolean | undefined;
    twoFactorCode?: string | undefined;
    resetSharedKey?: boolean;
    resetRecoveryCodes?: boolean;
    forgetMachine?: boolean;
}

export class InfoResponse implements IInfoResponse {
    email?: string;
    isEmailConfirmed?: boolean;

    constructor(data?: IInfoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
        }
    }

    static fromJS(data: any): InfoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new InfoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        return data;
    }
}

export interface IInfoResponse {
    email?: string;
    isEmailConfirmed?: boolean;
}

export class InfoRequest implements IInfoRequest {
    newEmail?: string | undefined;
    newPassword?: string | undefined;
    oldPassword?: string | undefined;

    constructor(data?: IInfoRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newEmail = _data["newEmail"];
            this.newPassword = _data["newPassword"];
            this.oldPassword = _data["oldPassword"];
        }
    }

    static fromJS(data: any): InfoRequest {
        data = typeof data === 'object' ? data : {};
        let result = new InfoRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newEmail"] = this.newEmail;
        data["newPassword"] = this.newPassword;
        data["oldPassword"] = this.oldPassword;
        return data;
    }
}

export interface IInfoRequest {
    newEmail?: string | undefined;
    newPassword?: string | undefined;
    oldPassword?: string | undefined;
}

export class LoginResultDto implements ILoginResultDto {
    succeeded?: boolean;
    requires2FA?: boolean;
    user?: UserDto | undefined;
    errorMessage?: string | undefined;

    constructor(data?: ILoginResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.requires2FA = _data["requires2FA"];
            this.user = _data["user"] ? UserDto.fromJS(_data["user"]) : <any>undefined;
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): LoginResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["requires2FA"] = this.requires2FA;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

export interface ILoginResultDto {
    succeeded?: boolean;
    requires2FA?: boolean;
    user?: UserDto | undefined;
    errorMessage?: string | undefined;
}

export class UserDto implements IUserDto {
    id?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    isEmailConfirmed?: boolean;
    isAuthenticated?: boolean;
    is2FAEnabled?: boolean;
    roles?: string[];

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            this.isAuthenticated = _data["isAuthenticated"];
            this.is2FAEnabled = _data["is2FAEnabled"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["isAuthenticated"] = this.isAuthenticated;
        data["is2FAEnabled"] = this.is2FAEnabled;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface IUserDto {
    id?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    isEmailConfirmed?: boolean;
    isAuthenticated?: boolean;
    is2FAEnabled?: boolean;
    roles?: string[];
}

export class LoginCommand implements ILoginCommand {
    usernameOrEmail?: string | undefined;
    password?: string | undefined;
    twoFactorCode?: string | undefined;
    rememberMe?: boolean;

    constructor(data?: ILoginCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.usernameOrEmail = _data["usernameOrEmail"];
            this.password = _data["password"];
            this.twoFactorCode = _data["twoFactorCode"];
            this.rememberMe = _data["rememberMe"];
        }
    }

    static fromJS(data: any): LoginCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LoginCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usernameOrEmail"] = this.usernameOrEmail;
        data["password"] = this.password;
        data["twoFactorCode"] = this.twoFactorCode;
        data["rememberMe"] = this.rememberMe;
        return data;
    }
}

export interface ILoginCommand {
    usernameOrEmail?: string | undefined;
    password?: string | undefined;
    twoFactorCode?: string | undefined;
    rememberMe?: boolean;
}

export class ForgotPasswordCommand implements IForgotPasswordCommand {
    email?: string | undefined;

    constructor(data?: IForgotPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IForgotPasswordCommand {
    email?: string | undefined;
}

export class Result implements IResult {
    succeeded?: boolean;
    errors?: string[];

    constructor(data?: IResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): Result {
        data = typeof data === 'object' ? data : {};
        let result = new Result();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IResult {
    succeeded?: boolean;
    errors?: string[];
}

export class ResetPasswordCommand implements IResetPasswordCommand {
    email?: string;
    token?: string;
    newPassword?: string;

    constructor(data?: IResetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.token = _data["token"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["token"] = this.token;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IResetPasswordCommand {
    email?: string;
    token?: string;
    newPassword?: string;
}

export class ConfirmEmailCommand implements IConfirmEmailCommand {
    userId?: string;
    token?: string;

    constructor(data?: IConfirmEmailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ConfirmEmailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmEmailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["token"] = this.token;
        return data;
    }
}

export interface IConfirmEmailCommand {
    userId?: string;
    token?: string;
}

export class ResendConfirmationEmailDto implements IResendConfirmationEmailDto {
    email!: string;

    constructor(data?: IResendConfirmationEmailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ResendConfirmationEmailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResendConfirmationEmailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IResendConfirmationEmailDto {
    email: string;
}

export class GenerateTwoFactorKeyResponse implements IGenerateTwoFactorKeyResponse {
    sharedKey?: string;
    authenticatorUri?: string;

    constructor(data?: IGenerateTwoFactorKeyResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sharedKey = _data["sharedKey"];
            this.authenticatorUri = _data["authenticatorUri"];
        }
    }

    static fromJS(data: any): GenerateTwoFactorKeyResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateTwoFactorKeyResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sharedKey"] = this.sharedKey;
        data["authenticatorUri"] = this.authenticatorUri;
        return data;
    }
}

export interface IGenerateTwoFactorKeyResponse {
    sharedKey?: string;
    authenticatorUri?: string;
}

export class Enable2faRequest implements IEnable2faRequest {
    code!: string;

    constructor(data?: IEnable2faRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): Enable2faRequest {
        data = typeof data === 'object' ? data : {};
        let result = new Enable2faRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        return data;
    }
}

export interface IEnable2faRequest {
    code: string;
}

export class CreateEstatePropertyCommand implements ICreateEstatePropertyCommand {
    dto?: CreateOrUpdateEstatePropertyDto;

    constructor(data?: ICreateEstatePropertyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dto = _data["dto"] ? CreateOrUpdateEstatePropertyDto.fromJS(_data["dto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateEstatePropertyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEstatePropertyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dto"] = this.dto ? this.dto.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateEstatePropertyCommand {
    dto?: CreateOrUpdateEstatePropertyDto;
}

export class CreateOrUpdateEstatePropertyDto implements ICreateOrUpdateEstatePropertyDto {
    id?: string;
    streetName!: string;
    houseNumber!: string;
    neighborhood?: string | undefined;
    city!: string;
    state!: string;
    zipCode!: string;
    country!: string;
    location!: LocationDto;
    title!: string;
    type!: string;
    areaValue?: number;
    areaUnit?: number;
    bedrooms?: number;
    bathrooms?: number;
    hasGarage!: boolean;
    garageSpaces!: number;
    visits?: number;
    createdOnUtc!: Date;
    images!: string[];
    publicDeed!: string;
    propertyPlans!: string;
    taxReceipts!: string;
    otherDocuments?: string[] | undefined;
    mainImage?: string | undefined;
    mainImageUrl?: string | undefined;
    propertyImages?: PropertyImageDto[] | undefined;
    ownerId?: string | undefined;
    description!: string;
    availableFrom?: Date;
    arePetsAllowed?: boolean;
    capacity?: number;
    currency?: Currency;
    salePrice?: number | undefined;
    rentPrice?: number | undefined;
    hasCommonExpenses?: boolean;
    commonExpensesAmount?: number | undefined;
    isElectricityIncluded?: boolean;
    isWaterIncluded?: boolean;
    isPriceVisible?: boolean;
    status?: PropertyStatus;
    isActive?: boolean;
    isPropertyVisible?: boolean;

    constructor(data?: ICreateOrUpdateEstatePropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.location = new LocationDto();
            this.images = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.streetName = _data["streetName"];
            this.houseNumber = _data["houseNumber"];
            this.neighborhood = _data["neighborhood"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.zipCode = _data["zipCode"];
            this.country = _data["country"];
            this.location = _data["location"] ? LocationDto.fromJS(_data["location"]) : new LocationDto();
            this.title = _data["title"];
            this.type = _data["type"];
            this.areaValue = _data["areaValue"];
            this.areaUnit = _data["areaUnit"];
            this.bedrooms = _data["bedrooms"];
            this.bathrooms = _data["bathrooms"];
            this.hasGarage = _data["hasGarage"];
            this.garageSpaces = _data["garageSpaces"];
            this.visits = _data["visits"];
            this.createdOnUtc = _data["createdOnUtc"] ? new Date(_data["createdOnUtc"].toString()) : <any>undefined;
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(item);
            }
            this.publicDeed = _data["publicDeed"];
            this.propertyPlans = _data["propertyPlans"];
            this.taxReceipts = _data["taxReceipts"];
            if (Array.isArray(_data["otherDocuments"])) {
                this.otherDocuments = [] as any;
                for (let item of _data["otherDocuments"])
                    this.otherDocuments!.push(item);
            }
            this.mainImage = _data["mainImage"];
            this.mainImageUrl = _data["mainImageUrl"];
            if (Array.isArray(_data["propertyImages"])) {
                this.propertyImages = [] as any;
                for (let item of _data["propertyImages"])
                    this.propertyImages!.push(PropertyImageDto.fromJS(item));
            }
            this.ownerId = _data["ownerId"];
            this.description = _data["description"];
            this.availableFrom = _data["availableFrom"] ? new Date(_data["availableFrom"].toString()) : <any>undefined;
            this.arePetsAllowed = _data["arePetsAllowed"];
            this.capacity = _data["capacity"];
            this.currency = _data["currency"];
            this.salePrice = _data["salePrice"];
            this.rentPrice = _data["rentPrice"];
            this.hasCommonExpenses = _data["hasCommonExpenses"];
            this.commonExpensesAmount = _data["commonExpensesAmount"];
            this.isElectricityIncluded = _data["isElectricityIncluded"];
            this.isWaterIncluded = _data["isWaterIncluded"];
            this.isPriceVisible = _data["isPriceVisible"];
            this.status = _data["status"];
            this.isActive = _data["isActive"];
            this.isPropertyVisible = _data["isPropertyVisible"];
        }
    }

    static fromJS(data: any): CreateOrUpdateEstatePropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateEstatePropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["streetName"] = this.streetName;
        data["houseNumber"] = this.houseNumber;
        data["neighborhood"] = this.neighborhood;
        data["city"] = this.city;
        data["state"] = this.state;
        data["zipCode"] = this.zipCode;
        data["country"] = this.country;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["title"] = this.title;
        data["type"] = this.type;
        data["areaValue"] = this.areaValue;
        data["areaUnit"] = this.areaUnit;
        data["bedrooms"] = this.bedrooms;
        data["bathrooms"] = this.bathrooms;
        data["hasGarage"] = this.hasGarage;
        data["garageSpaces"] = this.garageSpaces;
        data["visits"] = this.visits;
        data["createdOnUtc"] = this.createdOnUtc ? this.createdOnUtc.toISOString() : <any>undefined;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item);
        }
        data["publicDeed"] = this.publicDeed;
        data["propertyPlans"] = this.propertyPlans;
        data["taxReceipts"] = this.taxReceipts;
        if (Array.isArray(this.otherDocuments)) {
            data["otherDocuments"] = [];
            for (let item of this.otherDocuments)
                data["otherDocuments"].push(item);
        }
        data["mainImage"] = this.mainImage;
        data["mainImageUrl"] = this.mainImageUrl;
        if (Array.isArray(this.propertyImages)) {
            data["propertyImages"] = [];
            for (let item of this.propertyImages)
                data["propertyImages"].push(item.toJSON());
        }
        data["ownerId"] = this.ownerId;
        data["description"] = this.description;
        data["availableFrom"] = this.availableFrom ? this.availableFrom.toISOString() : <any>undefined;
        data["arePetsAllowed"] = this.arePetsAllowed;
        data["capacity"] = this.capacity;
        data["currency"] = this.currency;
        data["salePrice"] = this.salePrice;
        data["rentPrice"] = this.rentPrice;
        data["hasCommonExpenses"] = this.hasCommonExpenses;
        data["commonExpensesAmount"] = this.commonExpensesAmount;
        data["isElectricityIncluded"] = this.isElectricityIncluded;
        data["isWaterIncluded"] = this.isWaterIncluded;
        data["isPriceVisible"] = this.isPriceVisible;
        data["status"] = this.status;
        data["isActive"] = this.isActive;
        data["isPropertyVisible"] = this.isPropertyVisible;
        return data;
    }
}

export interface ICreateOrUpdateEstatePropertyDto {
    id?: string;
    streetName: string;
    houseNumber: string;
    neighborhood?: string | undefined;
    city: string;
    state: string;
    zipCode: string;
    country: string;
    location: LocationDto;
    title: string;
    type: string;
    areaValue?: number;
    areaUnit?: number;
    bedrooms?: number;
    bathrooms?: number;
    hasGarage: boolean;
    garageSpaces: number;
    visits?: number;
    createdOnUtc: Date;
    images: string[];
    publicDeed: string;
    propertyPlans: string;
    taxReceipts: string;
    otherDocuments?: string[] | undefined;
    mainImage?: string | undefined;
    mainImageUrl?: string | undefined;
    propertyImages?: PropertyImageDto[] | undefined;
    ownerId?: string | undefined;
    description: string;
    availableFrom?: Date;
    arePetsAllowed?: boolean;
    capacity?: number;
    currency?: Currency;
    salePrice?: number | undefined;
    rentPrice?: number | undefined;
    hasCommonExpenses?: boolean;
    commonExpensesAmount?: number | undefined;
    isElectricityIncluded?: boolean;
    isWaterIncluded?: boolean;
    isPriceVisible?: boolean;
    status?: PropertyStatus;
    isActive?: boolean;
    isPropertyVisible?: boolean;
}

export class LocationDto implements ILocationDto {
    lat?: number;
    lng?: number;

    constructor(data?: ILocationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lat = _data["lat"];
            this.lng = _data["lng"];
        }
    }

    static fromJS(data: any): LocationDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lat"] = this.lat;
        data["lng"] = this.lng;
        return data;
    }
}

export interface ILocationDto {
    lat?: number;
    lng?: number;
}

export class PropertyImageDto implements IPropertyImageDto {
    id?: string | undefined;
    url?: string;
    altText?: string | undefined;
    isMain?: boolean | undefined;
    estatePropertyId?: string;
    fileName?: string;
    contentType?: string;
    imageData?: string;
    isPublic?: boolean;

    constructor(data?: IPropertyImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.url = _data["url"];
            this.altText = _data["altText"];
            this.isMain = _data["isMain"];
            this.estatePropertyId = _data["estatePropertyId"];
            this.fileName = _data["fileName"];
            this.contentType = _data["contentType"];
            this.imageData = _data["imageData"];
            this.isPublic = _data["isPublic"];
        }
    }

    static fromJS(data: any): PropertyImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        data["altText"] = this.altText;
        data["isMain"] = this.isMain;
        data["estatePropertyId"] = this.estatePropertyId;
        data["fileName"] = this.fileName;
        data["contentType"] = this.contentType;
        data["imageData"] = this.imageData;
        data["isPublic"] = this.isPublic;
        return data;
    }
}

export interface IPropertyImageDto {
    id?: string | undefined;
    url?: string;
    altText?: string | undefined;
    isMain?: boolean | undefined;
    estatePropertyId?: string;
    fileName?: string;
    contentType?: string;
    imageData?: string;
    isPublic?: boolean;
}

export enum Currency {
    USD = 0,
    UYU = 1,
    BRL = 2,
    EUR = 3,
    GBP = 4,
}

export enum PropertyStatus {
    Sale = 0,
    Rent = 1,
    Reserved = 2,
    Sold = 3,
    Unavailable = 4,
}

export class UpdateEstatePropertyCommand implements IUpdateEstatePropertyCommand {
    estateProperty?: CreateOrUpdateEstatePropertyDto;
    mainImage?: CreateOrUpdatePropertyImageDto | undefined;
    propertyImages?: CreateOrUpdatePropertyImageDto[] | undefined;
    featuredDescriptionId?: string | undefined;
    estatePropertyDescriptions?: CreateOrUpdateEstatePropertyDescriptionDto[] | undefined;

    constructor(data?: IUpdateEstatePropertyCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.estateProperty = _data["estateProperty"] ? CreateOrUpdateEstatePropertyDto.fromJS(_data["estateProperty"]) : <any>undefined;
            this.mainImage = _data["mainImage"] ? CreateOrUpdatePropertyImageDto.fromJS(_data["mainImage"]) : <any>undefined;
            if (Array.isArray(_data["propertyImages"])) {
                this.propertyImages = [] as any;
                for (let item of _data["propertyImages"])
                    this.propertyImages!.push(CreateOrUpdatePropertyImageDto.fromJS(item));
            }
            this.featuredDescriptionId = _data["featuredDescriptionId"];
            if (Array.isArray(_data["estatePropertyDescriptions"])) {
                this.estatePropertyDescriptions = [] as any;
                for (let item of _data["estatePropertyDescriptions"])
                    this.estatePropertyDescriptions!.push(CreateOrUpdateEstatePropertyDescriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateEstatePropertyCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEstatePropertyCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["estateProperty"] = this.estateProperty ? this.estateProperty.toJSON() : <any>undefined;
        data["mainImage"] = this.mainImage ? this.mainImage.toJSON() : <any>undefined;
        if (Array.isArray(this.propertyImages)) {
            data["propertyImages"] = [];
            for (let item of this.propertyImages)
                data["propertyImages"].push(item.toJSON());
        }
        data["featuredDescriptionId"] = this.featuredDescriptionId;
        if (Array.isArray(this.estatePropertyDescriptions)) {
            data["estatePropertyDescriptions"] = [];
            for (let item of this.estatePropertyDescriptions)
                data["estatePropertyDescriptions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateEstatePropertyCommand {
    estateProperty?: CreateOrUpdateEstatePropertyDto;
    mainImage?: CreateOrUpdatePropertyImageDto | undefined;
    propertyImages?: CreateOrUpdatePropertyImageDto[] | undefined;
    featuredDescriptionId?: string | undefined;
    estatePropertyDescriptions?: CreateOrUpdateEstatePropertyDescriptionDto[] | undefined;
}

export class CreateOrUpdatePropertyImageDto implements ICreateOrUpdatePropertyImageDto {
    id?: string | undefined;
    url?: string;
    altText?: string | undefined;
    isMain?: boolean | undefined;
    estatePropertyId?: string;
    fileName?: string;
    contentType?: string;
    imageData?: string;
    isPublic?: boolean;

    constructor(data?: ICreateOrUpdatePropertyImageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.url = _data["url"];
            this.altText = _data["altText"];
            this.isMain = _data["isMain"];
            this.estatePropertyId = _data["estatePropertyId"];
            this.fileName = _data["fileName"];
            this.contentType = _data["contentType"];
            this.imageData = _data["imageData"];
            this.isPublic = _data["isPublic"];
        }
    }

    static fromJS(data: any): CreateOrUpdatePropertyImageDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdatePropertyImageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        data["altText"] = this.altText;
        data["isMain"] = this.isMain;
        data["estatePropertyId"] = this.estatePropertyId;
        data["fileName"] = this.fileName;
        data["contentType"] = this.contentType;
        data["imageData"] = this.imageData;
        data["isPublic"] = this.isPublic;
        return data;
    }
}

export interface ICreateOrUpdatePropertyImageDto {
    id?: string | undefined;
    url?: string;
    altText?: string | undefined;
    isMain?: boolean | undefined;
    estatePropertyId?: string;
    fileName?: string;
    contentType?: string;
    imageData?: string;
    isPublic?: boolean;
}

export class CreateOrUpdateEstatePropertyDescriptionDto implements ICreateOrUpdateEstatePropertyDescriptionDto {
    id?: string | undefined;
    estatePropertyId?: string | undefined;
    availableFrom?: Date | undefined;
    availableTo?: Date | undefined;
    listedPrice?: number;
    rentPrice?: number;
    soldPrice?: number;
    isActive?: boolean;

    constructor(data?: ICreateOrUpdateEstatePropertyDescriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.estatePropertyId = _data["estatePropertyId"];
            this.availableFrom = _data["availableFrom"] ? new Date(_data["availableFrom"].toString()) : <any>undefined;
            this.availableTo = _data["availableTo"] ? new Date(_data["availableTo"].toString()) : <any>undefined;
            this.listedPrice = _data["listedPrice"];
            this.rentPrice = _data["rentPrice"];
            this.soldPrice = _data["soldPrice"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateOrUpdateEstatePropertyDescriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateEstatePropertyDescriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["estatePropertyId"] = this.estatePropertyId;
        data["availableFrom"] = this.availableFrom ? this.availableFrom.toISOString() : <any>undefined;
        data["availableTo"] = this.availableTo ? this.availableTo.toISOString() : <any>undefined;
        data["listedPrice"] = this.listedPrice;
        data["rentPrice"] = this.rentPrice;
        data["soldPrice"] = this.soldPrice;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface ICreateOrUpdateEstatePropertyDescriptionDto {
    id?: string | undefined;
    estatePropertyId?: string | undefined;
    availableFrom?: Date | undefined;
    availableTo?: Date | undefined;
    listedPrice?: number;
    rentPrice?: number;
    soldPrice?: number;
    isActive?: boolean;
}

export class PaginatedMessageResultDto implements IPaginatedMessageResultDto {
    data?: MessageDto[];
    total?: number;
    page?: number;
    totalPages?: number;

    constructor(data?: IPaginatedMessageResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(MessageDto.fromJS(item));
            }
            this.total = _data["total"];
            this.page = _data["page"];
            this.totalPages = _data["totalPages"];
        }
    }

    static fromJS(data: any): PaginatedMessageResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedMessageResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        data["page"] = this.page;
        data["totalPages"] = this.totalPages;
        return data;
    }
}

export interface IPaginatedMessageResultDto {
    data?: MessageDto[];
    total?: number;
    page?: number;
    totalPages?: number;
}

export class MessageDto implements IMessageDto {
    id?: string;
    threadId?: string | undefined;
    senderId?: string | undefined;
    senderName?: string;
    senderEmail?: string | undefined;
    recipientId?: string | undefined;
    propertyId?: string | undefined;
    propertyTitle?: string | undefined;
    subject?: string;
    snippet?: string;
    createdAt?: string;
    isRead?: boolean;
    isReplied?: boolean;
    isStarred?: boolean;
    isArchived?: boolean;

    constructor(data?: IMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.threadId = _data["threadId"];
            this.senderId = _data["senderId"];
            this.senderName = _data["senderName"];
            this.senderEmail = _data["senderEmail"];
            this.recipientId = _data["recipientId"];
            this.propertyId = _data["propertyId"];
            this.propertyTitle = _data["propertyTitle"];
            this.subject = _data["subject"];
            this.snippet = _data["snippet"];
            this.createdAt = _data["createdAt"];
            this.isRead = _data["isRead"];
            this.isReplied = _data["isReplied"];
            this.isStarred = _data["isStarred"];
            this.isArchived = _data["isArchived"];
        }
    }

    static fromJS(data: any): MessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["threadId"] = this.threadId;
        data["senderId"] = this.senderId;
        data["senderName"] = this.senderName;
        data["senderEmail"] = this.senderEmail;
        data["recipientId"] = this.recipientId;
        data["propertyId"] = this.propertyId;
        data["propertyTitle"] = this.propertyTitle;
        data["subject"] = this.subject;
        data["snippet"] = this.snippet;
        data["createdAt"] = this.createdAt;
        data["isRead"] = this.isRead;
        data["isReplied"] = this.isReplied;
        data["isStarred"] = this.isStarred;
        data["isArchived"] = this.isArchived;
        return data;
    }
}

export interface IMessageDto {
    id?: string;
    threadId?: string | undefined;
    senderId?: string | undefined;
    senderName?: string;
    senderEmail?: string | undefined;
    recipientId?: string | undefined;
    propertyId?: string | undefined;
    propertyTitle?: string | undefined;
    subject?: string;
    snippet?: string;
    createdAt?: string;
    isRead?: boolean;
    isReplied?: boolean;
    isStarred?: boolean;
    isArchived?: boolean;
}

export class MessageDetailDto extends MessageDto implements IMessageDetailDto {
    fullBody?: string;
    previousMessagesInThread?: MessageDto[];

    constructor(data?: IMessageDetailDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fullBody = _data["fullBody"];
            if (Array.isArray(_data["previousMessagesInThread"])) {
                this.previousMessagesInThread = [] as any;
                for (let item of _data["previousMessagesInThread"])
                    this.previousMessagesInThread!.push(MessageDto.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): MessageDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new MessageDetailDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullBody"] = this.fullBody;
        if (Array.isArray(this.previousMessagesInThread)) {
            data["previousMessagesInThread"] = [];
            for (let item of this.previousMessagesInThread)
                data["previousMessagesInThread"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IMessageDetailDto extends IMessageDto {
    fullBody?: string;
    previousMessagesInThread?: MessageDto[];
}

export class SendMessageDto implements ISendMessageDto {
    recipientId!: string;
    propertyId?: string | undefined;
    subject!: string;
    body!: string;
    inReplyToMessageId?: string | undefined;
    threadId?: string | undefined;

    constructor(data?: ISendMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recipientId = _data["recipientId"];
            this.propertyId = _data["propertyId"];
            this.subject = _data["subject"];
            this.body = _data["body"];
            this.inReplyToMessageId = _data["inReplyToMessageId"];
            this.threadId = _data["threadId"];
        }
    }

    static fromJS(data: any): SendMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recipientId"] = this.recipientId;
        data["propertyId"] = this.propertyId;
        data["subject"] = this.subject;
        data["body"] = this.body;
        data["inReplyToMessageId"] = this.inReplyToMessageId;
        data["threadId"] = this.threadId;
        return data;
    }
}

export interface ISendMessageDto {
    recipientId: string;
    propertyId?: string | undefined;
    subject: string;
    body: string;
    inReplyToMessageId?: string | undefined;
    threadId?: string | undefined;
}

export class TabCountsDto implements ITabCountsDto {
    inbox?: number;
    starred?: number;
    replied?: number;
    archived?: number;
    sent?: number;
    trash?: number;

    constructor(data?: ITabCountsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.inbox = _data["inbox"];
            this.starred = _data["starred"];
            this.replied = _data["replied"];
            this.archived = _data["archived"];
            this.sent = _data["sent"];
            this.trash = _data["trash"];
        }
    }

    static fromJS(data: any): TabCountsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TabCountsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inbox"] = this.inbox;
        data["starred"] = this.starred;
        data["replied"] = this.replied;
        data["archived"] = this.archived;
        data["sent"] = this.sent;
        data["trash"] = this.trash;
        return data;
    }
}

export interface ITabCountsDto {
    inbox?: number;
    starred?: number;
    replied?: number;
    archived?: number;
    sent?: number;
    trash?: number;
}

export class ProfileDataDto implements IProfileDataDto {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    title?: string | undefined;
    avatarUrl?: string | undefined;
    address?: AddressDto | undefined;

    constructor(data?: IProfileDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.title = _data["title"];
            this.avatarUrl = _data["avatarUrl"];
            this.address = _data["address"] ? AddressDto.fromJS(_data["address"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProfileDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["title"] = this.title;
        data["avatarUrl"] = this.avatarUrl;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProfileDataDto {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    title?: string | undefined;
    avatarUrl?: string | undefined;
    address?: AddressDto | undefined;
}

export class AddressDto implements IAddressDto {
    street?: string | undefined;
    street2?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    postalCode?: string | undefined;
    country?: string | undefined;

    constructor(data?: IAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.street = _data["street"];
            this.street2 = _data["street2"];
            this.city = _data["city"];
            this.state = _data["state"];
            this.postalCode = _data["postalCode"];
            this.country = _data["country"];
        }
    }

    static fromJS(data: any): AddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["street"] = this.street;
        data["street2"] = this.street2;
        data["city"] = this.city;
        data["state"] = this.state;
        data["postalCode"] = this.postalCode;
        data["country"] = this.country;
        return data;
    }
}

export interface IAddressDto {
    street?: string | undefined;
    street2?: string | undefined;
    city?: string | undefined;
    state?: string | undefined;
    postalCode?: string | undefined;
    country?: string | undefined;
}

export class UpdateProfileDto implements IUpdateProfileDto {
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    title?: string | undefined;
    address?: AddressDto | undefined;

    constructor(data?: IUpdateProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.title = _data["title"];
            this.address = _data["address"] ? AddressDto.fromJS(_data["address"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["title"] = this.title;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateProfileDto {
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    title?: string | undefined;
    address?: AddressDto | undefined;
}

export class ChangePasswordDto implements IChangePasswordDto {
    oldPassword!: string;
    newPassword!: string;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.oldPassword = _data["oldPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["oldPassword"] = this.oldPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordDto {
    oldPassword: string;
    newPassword: string;
}

export class MonthlySummaryDataDto implements IMonthlySummaryDataDto {
    visits?: DateCountDto[];
    messages?: DateCountDto[];

    constructor(data?: IMonthlySummaryDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["visits"])) {
                this.visits = [] as any;
                for (let item of _data["visits"])
                    this.visits!.push(DateCountDto.fromJS(item));
            }
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(DateCountDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MonthlySummaryDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new MonthlySummaryDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.visits)) {
            data["visits"] = [];
            for (let item of this.visits)
                data["visits"].push(item.toJSON());
        }
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMonthlySummaryDataDto {
    visits?: DateCountDto[];
    messages?: DateCountDto[];
}

export class DateCountDto implements IDateCountDto {
    date?: string;
    count?: number;

    constructor(data?: IDateCountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): DateCountDto {
        data = typeof data === 'object' ? data : {};
        let result = new DateCountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["count"] = this.count;
        return data;
    }
}

export interface IDateCountDto {
    date?: string;
    count?: number;
}

export class GeneralTotalsDataDto implements IGeneralTotalsDataDto {
    totalProperties?: number;
    totalVisitsLifetime?: number;
    totalMessagesLifetime?: number;
    activeListings?: number | undefined;
    averagePrice?: number | undefined;

    constructor(data?: IGeneralTotalsDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalProperties = _data["totalProperties"];
            this.totalVisitsLifetime = _data["totalVisitsLifetime"];
            this.totalMessagesLifetime = _data["totalMessagesLifetime"];
            this.activeListings = _data["activeListings"];
            this.averagePrice = _data["averagePrice"];
        }
    }

    static fromJS(data: any): GeneralTotalsDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralTotalsDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProperties"] = this.totalProperties;
        data["totalVisitsLifetime"] = this.totalVisitsLifetime;
        data["totalMessagesLifetime"] = this.totalMessagesLifetime;
        data["activeListings"] = this.activeListings;
        data["averagePrice"] = this.averagePrice;
        return data;
    }
}

export interface IGeneralTotalsDataDto {
    totalProperties?: number;
    totalVisitsLifetime?: number;
    totalMessagesLifetime?: number;
    activeListings?: number | undefined;
    averagePrice?: number | undefined;
}

export class VisitsByPropertyDataDto implements IVisitsByPropertyDataDto {
    data?: PropertyVisitStatDto[];
    total?: number;
    page?: number;
    limit?: number;

    constructor(data?: IVisitsByPropertyDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(PropertyVisitStatDto.fromJS(item));
            }
            this.total = _data["total"];
            this.page = _data["page"];
            this.limit = _data["limit"];
        }
    }

    static fromJS(data: any): VisitsByPropertyDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new VisitsByPropertyDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["total"] = this.total;
        data["page"] = this.page;
        data["limit"] = this.limit;
        return data;
    }
}

export interface IVisitsByPropertyDataDto {
    data?: PropertyVisitStatDto[];
    total?: number;
    page?: number;
    limit?: number;
}

export class PropertyVisitStatDto implements IPropertyVisitStatDto {
    propertyId?: string;
    propertyTitle?: string;
    address?: string | undefined;
    visitCount?: number;
    price?: number | undefined;
    status?: string | undefined;
    messages?: number | undefined;
    messagesTrend?: string | undefined;
    visitsTrend?: string | undefined;
    conversion?: string | undefined;
    conversionTrend?: string | undefined;

    constructor(data?: IPropertyVisitStatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyId = _data["propertyId"];
            this.propertyTitle = _data["propertyTitle"];
            this.address = _data["address"];
            this.visitCount = _data["visitCount"];
            this.price = _data["price"];
            this.status = _data["status"];
            this.messages = _data["messages"];
            this.messagesTrend = _data["messagesTrend"];
            this.visitsTrend = _data["visitsTrend"];
            this.conversion = _data["conversion"];
            this.conversionTrend = _data["conversionTrend"];
        }
    }

    static fromJS(data: any): PropertyVisitStatDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyVisitStatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyId"] = this.propertyId;
        data["propertyTitle"] = this.propertyTitle;
        data["address"] = this.address;
        data["visitCount"] = this.visitCount;
        data["price"] = this.price;
        data["status"] = this.status;
        data["messages"] = this.messages;
        data["messagesTrend"] = this.messagesTrend;
        data["visitsTrend"] = this.visitsTrend;
        data["conversion"] = this.conversion;
        data["conversionTrend"] = this.conversionTrend;
        return data;
    }
}

export interface IPropertyVisitStatDto {
    propertyId?: string;
    propertyTitle?: string;
    address?: string | undefined;
    visitCount?: number;
    price?: number | undefined;
    status?: string | undefined;
    messages?: number | undefined;
    messagesTrend?: string | undefined;
    visitsTrend?: string | undefined;
    conversion?: string | undefined;
    conversionTrend?: string | undefined;
}

export class PropertySpecificReportDataDto implements IPropertySpecificReportDataDto {
    propertyDetails?: PropertyDetailsForReportDto;
    visitTrend?: DateCountDto[];
    messageTrend?: DateCountDto[];
    conversionRate?: number | undefined;
    averageTimeToRespond?: string | undefined;

    constructor(data?: IPropertySpecificReportDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyDetails = _data["propertyDetails"] ? PropertyDetailsForReportDto.fromJS(_data["propertyDetails"]) : <any>undefined;
            if (Array.isArray(_data["visitTrend"])) {
                this.visitTrend = [] as any;
                for (let item of _data["visitTrend"])
                    this.visitTrend!.push(DateCountDto.fromJS(item));
            }
            if (Array.isArray(_data["messageTrend"])) {
                this.messageTrend = [] as any;
                for (let item of _data["messageTrend"])
                    this.messageTrend!.push(DateCountDto.fromJS(item));
            }
            this.conversionRate = _data["conversionRate"];
            this.averageTimeToRespond = _data["averageTimeToRespond"];
        }
    }

    static fromJS(data: any): PropertySpecificReportDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertySpecificReportDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyDetails"] = this.propertyDetails ? this.propertyDetails.toJSON() : <any>undefined;
        if (Array.isArray(this.visitTrend)) {
            data["visitTrend"] = [];
            for (let item of this.visitTrend)
                data["visitTrend"].push(item.toJSON());
        }
        if (Array.isArray(this.messageTrend)) {
            data["messageTrend"] = [];
            for (let item of this.messageTrend)
                data["messageTrend"].push(item.toJSON());
        }
        data["conversionRate"] = this.conversionRate;
        data["averageTimeToRespond"] = this.averageTimeToRespond;
        return data;
    }
}

export interface IPropertySpecificReportDataDto {
    propertyDetails?: PropertyDetailsForReportDto;
    visitTrend?: DateCountDto[];
    messageTrend?: DateCountDto[];
    conversionRate?: number | undefined;
    averageTimeToRespond?: string | undefined;
}

export class PropertyDetailsForReportDto implements IPropertyDetailsForReportDto {
    id?: string;
    title?: string;
    address?: string | undefined;
    price?: string | undefined;
    status?: string | undefined;
    type?: string | undefined;

    constructor(data?: IPropertyDetailsForReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.address = _data["address"];
            this.price = _data["price"];
            this.status = _data["status"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): PropertyDetailsForReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new PropertyDetailsForReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["address"] = this.address;
        data["price"] = this.price;
        data["status"] = this.status;
        data["type"] = this.type;
        return data;
    }
}

export interface IPropertyDetailsForReportDto {
    id?: string;
    title?: string;
    address?: string | undefined;
    price?: string | undefined;
    status?: string | undefined;
    type?: string | undefined;
}

export class DashboardSummaryDataDto implements IDashboardSummaryDataDto {
    visits?: DashboardSummaryStatDto;
    messages?: DashboardSummaryStatDto;
    totalProperties?: DashboardSummaryStatDto | undefined;
    conversionRate?: DashboardSummaryStatDto | undefined;

    constructor(data?: IDashboardSummaryDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.visits = _data["visits"] ? DashboardSummaryStatDto.fromJS(_data["visits"]) : <any>undefined;
            this.messages = _data["messages"] ? DashboardSummaryStatDto.fromJS(_data["messages"]) : <any>undefined;
            this.totalProperties = _data["totalProperties"] ? DashboardSummaryStatDto.fromJS(_data["totalProperties"]) : <any>undefined;
            this.conversionRate = _data["conversionRate"] ? DashboardSummaryStatDto.fromJS(_data["conversionRate"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DashboardSummaryDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardSummaryDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["visits"] = this.visits ? this.visits.toJSON() : <any>undefined;
        data["messages"] = this.messages ? this.messages.toJSON() : <any>undefined;
        data["totalProperties"] = this.totalProperties ? this.totalProperties.toJSON() : <any>undefined;
        data["conversionRate"] = this.conversionRate ? this.conversionRate.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDashboardSummaryDataDto {
    visits?: DashboardSummaryStatDto;
    messages?: DashboardSummaryStatDto;
    totalProperties?: DashboardSummaryStatDto | undefined;
    conversionRate?: DashboardSummaryStatDto | undefined;
}

export class DashboardSummaryStatDto implements IDashboardSummaryStatDto {
    currentPeriod?: number;
    percentageChange?: number | undefined;
    changeDirection?: string | undefined;

    constructor(data?: IDashboardSummaryStatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPeriod = _data["currentPeriod"];
            this.percentageChange = _data["percentageChange"];
            this.changeDirection = _data["changeDirection"];
        }
    }

    static fromJS(data: any): DashboardSummaryStatDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardSummaryStatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPeriod"] = this.currentPeriod;
        data["percentageChange"] = this.percentageChange;
        data["changeDirection"] = this.changeDirection;
        return data;
    }
}

export interface IDashboardSummaryStatDto {
    currentPeriod?: number;
    percentageChange?: number | undefined;
    changeDirection?: string | undefined;
}

export class DailyVisitDto implements IDailyVisitDto {
    date?: string;
    dayName?: string | undefined;
    visits?: number;

    constructor(data?: IDailyVisitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"];
            this.dayName = _data["dayName"];
            this.visits = _data["visits"];
        }
    }

    static fromJS(data: any): DailyVisitDto {
        data = typeof data === 'object' ? data : {};
        let result = new DailyVisitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["dayName"] = this.dayName;
        data["visits"] = this.visits;
        return data;
    }
}

export interface IDailyVisitDto {
    date?: string;
    dayName?: string | undefined;
    visits?: number;
}

export class VisitSourceDto implements IVisitSourceDto {
    source?: string;
    visits?: number;
    color?: string | undefined;

    constructor(data?: IVisitSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.source = _data["source"];
            this.visits = _data["visits"];
            this.color = _data["color"];
        }
    }

    static fromJS(data: any): VisitSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new VisitSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["source"] = this.source;
        data["visits"] = this.visits;
        data["color"] = this.color;
        return data;
    }
}

export interface IVisitSourceDto {
    source?: string;
    visits?: number;
    color?: string | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}